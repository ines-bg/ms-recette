name: Deploy Kubernetes

on:
  workflow_call:
    inputs:
      image-tag:
        required: true
        type: string
    outputs:
      service-url:
        description: "Service URL"
        value: ${{ jobs.deploy.outputs.service-url }}

env:
  IMAGE_NAME: ms-recette
  NAMESPACE: soa-integration

jobs:
  deploy:
    name: Deploy to Kubernetes (Minikube)
    runs-on: ubuntu-22.04
    timeout-minutes: 30
    outputs:
      service-url: ${{ steps.endpoint.outputs.service_url }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download Docker image
        uses: actions/download-artifact@v4
        with:
          name: docker-image
          path: ./

      - name: Setup Minikube (manual installation)
        run: |
          echo "ğŸ“¦ Installing Minikube..."
          curl -LO https://storage.googleapis.com/minikube/releases/v1.32.0/minikube-linux-amd64
          sudo install minikube-linux-amd64 /usr/local/bin/minikube
          rm minikube-linux-amd64
          
          echo "ğŸš€ Starting Minikube..."
          minikube start --driver=docker --memory=4096 --cpus=2 --kubernetes-version=v1.28.0
          
          echo "â³ Waiting for Minikube to be ready..."
          minikube status
          
          echo "âœ… Minikube started successfully"

      - name: Configure kubectl
        run: |
          echo "ğŸ”§ Configuring kubectl..."
          kubectl config use-context minikube
          kubectl config view
          
          echo "âœ… kubectl configured"

      - name: Verify Minikube
        run: |
          echo "ğŸ” Cluster info:"
          kubectl cluster-info
          
          echo "ğŸ“Š Nodes:"
          kubectl get nodes
          
          echo "ğŸ³ Docker env:"
          minikube docker-env

      - name: Load MS-Recette image into Minikube
        run: |
          echo "ğŸ“¥ Loading MS-Recette Docker image into Minikube..."
          minikube image load app-image.tar
          
          echo "ğŸ·ï¸ Tagging MS-Recette image inside Minikube..."
          minikube image tag ${{ env.IMAGE_NAME }}:${{ inputs.image-tag }} ${{ env.IMAGE_NAME }}:latest
          
          echo "ğŸ“‹ MS-Recette image inside Minikube:"
          minikube image ls | grep ${{ env.IMAGE_NAME }} || echo "âš ï¸  Image not found yet"
          
          echo "âœ… MS-Recette image loaded successfully"

      - name: Pull and Load MS-Persistance image
        run: |
          echo "ğŸ“¥ Pulling MS-Persistance image from Docker Hub..."
          docker pull abdboutchichi/ms-persistance:latest
          
          echo "ğŸ’¾ Saving MS-Persistance image to tar file..."
          docker save abdboutchichi/ms-persistance:latest -o /tmp/ms-persistance.tar
          
          echo "ğŸ“¦ Loading MS-Persistance into Minikube Docker daemon..."
          # Method 1: Use minikube's docker-env
          eval $(minikube -p minikube docker-env)
          docker load -i /tmp/ms-persistance.tar
          
          # Verify the image is loaded
          echo "ğŸ” Verifying MS-Persistance image in Minikube..."
          docker images | grep ms-persistance || {
            echo "âš ï¸  Image not visible, trying alternative method..."
            # Method 2: Direct load via minikube ssh
            minikube ssh "docker load -i /tmp/ms-persistance.tar" < /tmp/ms-persistance.tar
          }
          
          echo "âœ… MS-Persistance image successfully loaded into Minikube"
          
          # Cleanup
          rm -f /tmp/ms-persistance.tar

      - name: Create namespace
        run: |
          kubectl create namespace ${{ env.NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -
          echo "âœ… Namespace created/verified"

      - name: Deploy stack to Minikube (MySQL + MS-Persistance + MS-Recette)
        run: |
          echo "ğŸš€ Deploying complete stack..."
          kubectl apply -f .github/k8s-integration/deployment.yaml
          
          echo "ğŸ“Š Current deployments:"
          kubectl get deployments -n ${{ env.NAMESPACE }}
          
          echo "âœ… Stack deployed (MS-Recette + MS-Persistance + MySQL)"

      - name: Wait for pods to be created
        run: |
          echo "â³ Waiting 20 seconds for pods to be scheduled..."
          sleep 20
          
          echo "ğŸ“Š Current state:"
          kubectl get all -n ${{ env.NAMESPACE }}

      - name: Wait for MySQL to be ready
        run: |
          echo "â³ Waiting for MySQL to be ready (max 180s)..."
          kubectl wait --for=condition=ready pod -l app=mysql -n ${{ env.NAMESPACE }} --timeout=180s || {
            echo "âŒ MySQL not ready!"
            kubectl get pods -n ${{ env.NAMESPACE }} -l app=mysql
            kubectl describe pod -l app=mysql -n ${{ env.NAMESPACE }}
            kubectl logs -l app=mysql -n ${{ env.NAMESPACE }} --tail=50 || true
            exit 1
          }
          echo "âœ… MySQL is ready!"

      - name: Wait for MS-Persistance to be ready
        run: |
          echo "â³ Waiting for MS-Persistance to be ready (max 180s)..."
          kubectl wait --for=condition=ready pod -l app=ms-persistance -n ${{ env.NAMESPACE }} --timeout=180s || {
            echo "âŒ MS-Persistance not ready!"
            kubectl get pods -n ${{ env.NAMESPACE }} -l app=ms-persistance
            kubectl describe pod -l app=ms-persistance -n ${{ env.NAMESPACE }}
            kubectl logs -l app=ms-persistance -n ${{ env.NAMESPACE }} --tail=100 || true
            exit 1
          }
          echo "âœ… MS-Persistance is ready!"

      - name: Debug pods before rollout
        if: always()
        run: |
          echo "ğŸ” Current pods status:"
          kubectl get pods -n ${{ env.NAMESPACE }} -o wide
          
          echo ""
          echo "ğŸ” ms-recette pods details:"
          kubectl describe pods -l app=ms-recette -n ${{ env.NAMESPACE }} || echo "No ms-recette pods yet"
          
          echo ""
          echo "ğŸ” Recent events:"
          kubectl get events -n ${{ env.NAMESPACE }} --sort-by='.lastTimestamp' --field-selector type!=Normal | tail -20 || echo "No error events"

      - name: Wait for deployment
        run: |
          echo "â³ Waiting for deployment rollout..."
          kubectl rollout status deployment/ms-recette -n ${{ env.NAMESPACE }} --timeout=300s || {
            echo "âŒ Rollout timeout! Gathering debug info..."
            kubectl get pods -n ${{ env.NAMESPACE }} -o wide
            kubectl describe pods -n ${{ env.NAMESPACE }}
            kubectl logs -l app=ms-recette -n ${{ env.NAMESPACE }} --tail=50 || true
            exit 1
          }
          
          echo "âœ… Deployment successful"
          kubectl get pods -n ${{ env.NAMESPACE }} -o wide

      - name: Get service endpoint
        id: endpoint
        run: |
          kubectl wait --for=condition=ready pod -l app=ms-recette -n ${{ env.NAMESPACE }} --timeout=300s
          SERVICE_URL=$(minikube service ms-recette --url -n ${{ env.NAMESPACE }} 2>/dev/null || echo "")
          if [ -z "$SERVICE_URL" ]; then
            MINIKUBE_IP=$(minikube ip)
            NODEPORT=$(kubectl get svc ms-recette -n ${{ env.NAMESPACE }} -o jsonpath='{.spec.ports[0].nodePort}')
            SERVICE_URL="http://$MINIKUBE_IP:$NODEPORT"
          fi
          echo "service_url=$SERVICE_URL" >> $GITHUB_OUTPUT
          echo "Service accessible at: $SERVICE_URL"

      - name: Test service health
        run: |
          echo "ğŸ¥ Testing service health..."
          SERVICE_URL="${{ steps.endpoint.outputs.service_url }}"
          
          # Attendre que le service soit vraiment prÃªt
          for i in {1..12}; do
            if curl -f --connect-timeout 5 "$SERVICE_URL/actuator/health" 2>/dev/null; then
              echo "âœ… Service is healthy!"
              break
            fi
            echo "â³ Waiting for service to be fully ready ($i/12)..."
            sleep 5
          done
          
          # Test final
          curl -f "$SERVICE_URL/actuator/health" || \
          curl -f "$SERVICE_URL/health" || \
          curl -f "$SERVICE_URL/" || {
            echo "âŒ Health check failed"
            kubectl logs -l app=ms-recette -n ${{ env.NAMESPACE }} --tail=50
            exit 1
          }
          
          echo "âœ… Service is healthy and ready for tests"

      - name: Install Newman for integration tests
        working-directory: ./tests/newman
        run: |
          echo "ğŸ“¦ Installing Newman dependencies..."
          npm install
          echo "âœ… Newman installed"

      - name: Configure Newman environment
        working-directory: ./tests/newman
        run: |
          echo "ğŸ“ Configuring Newman with service URL..."
          SERVICE_URL="${{ steps.endpoint.outputs.service_url }}"
          
          jq --arg url "$SERVICE_URL" \
            '(.values[] | select(.key == "baseUrl") | .value) = $url' \
            env.json > env.tmp.json
          
          echo "ğŸ“‹ Environment configuration:"
          cat env.tmp.json | jq '.'
          echo "âœ… Environment configured with URL: $SERVICE_URL"

      - name: Run Newman integration tests
        working-directory: ./tests/newman
        run: |
          echo "ğŸš€ Starting Newman integration tests..."
          echo "ğŸ¯ Target: ${{ steps.endpoint.outputs.service_url }}"
          
          mkdir -p newman-results
          
          npx newman run ./collection.json \
            --environment ./env.tmp.json \
            --iteration-data ./dataset.json \
            --reporters cli,json \
            --reporter-json-export ./newman-results/newman-report.json \
            --timeout-request 30000 \
            --bail || {
              echo "âŒ Newman tests failed!"
              echo ""
              echo "ğŸ“Š Service status:"
              curl -v "${{ steps.endpoint.outputs.service_url }}/actuator/health" || true
              echo ""
              echo "ğŸ“‹ Pod logs:"
              kubectl logs -l app=ms-recette -n ${{ env.NAMESPACE }} --tail=100
              exit 1
            }
          
          echo ""
          echo "âœ… All Newman tests passed successfully!"

      - name: Upload Newman results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: newman-results
          path: tests/newman/newman-results/
          retention-days: 7

      - name: Upload service URL artifact
        run: |
          echo "${{ steps.endpoint.outputs.service_url }}" > service-url.txt

      - name: Upload service URL
        uses: actions/upload-artifact@v4
        with:
          name: service-url
          path: service-url.txt
          retention-days: 1


